# ðŸ”Ž BINARY SEARCH â€” C++ TEMPLATES & EXPLANATIONS FOR EACH PATTERN

---

## ðŸŸ¢ Pattern 1 â€” Classic Binary Search

### Sub-pattern: Exact Match
**When to use:** Find exact target in sorted array

```cpp
// Template 1: Standard Binary Search
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Prevent overflow
        
        if (nums[mid] == target) {
            return mid;  // Found
        } else if (nums[mid] < target) {
            left = mid + 1;  // Search right half
        } else {
            right = mid - 1;  // Search left half
        }
    }
    
    return -1;  // Not found
}
```

**Explanation:** 
- `left <= right` ensures we check every element
- `mid = left + (right - left) / 2` prevents integer overflow
- Three-way comparison: equal, less than, greater than
- Time: O(log n), Space: O(1)

---

## ðŸŸ¢ Pattern 2 â€” Boundaries (First / Last Position)

### Sub-pattern: First True / Lower Bound
**When to use:** Find first index where condition becomes true

```cpp
// Template 2A: Find First Position (Lower Bound)
int findFirstPosition(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size();  // Note: right = size, not size-1
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] >= target) {  // Condition: is mid >= target?
            right = mid;  // Move left (including mid)
        } else {
            left = mid + 1;  // Move right
        }
    }
    
    return left;  // First index where nums[i] >= target
}
```

### Sub-pattern: Last True / Upper Bound
**When to use:** Find last index where condition is true

```cpp
// Template 2B: Find Last Position (Upper Bound)
int findLastPosition(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            result = mid;      // Record found position
            left = mid + 1;    // Keep searching right
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;  // Last index with target
}
```

**Explanation:**
- Template 2A uses `left < right` and narrows to single index
- Template 2B records result and continues searching
- Perfect for "First Bad Version" (278), "Find First and Last Position" (34)

---

## ðŸŸ¢ Pattern 3 â€” Rotated Sorted Array

### Sub-pattern: Find Minimum in Rotated Array
**When to use:** Array was sorted then rotated

```cpp
// Template 3A: Find Minimum in Rotated Sorted Array
int findMin(vector<int>& nums) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] > nums[right]) {
            // Minimum is in right half
            left = mid + 1;
        } else {
            // Minimum is in left half (including mid)
            right = mid;
        }
    }
    
    return nums[left];  // Minimum element
}
```

### Sub-pattern: Search in Rotated Array
**When to use:** Find target in rotated sorted array

```cpp
// Template 3B: Search in Rotated Sorted Array
int searchRotated(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            return mid;
        }
        
        // Determine which half is sorted
        if (nums[left] <= nums[mid]) {  // Left half is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;  // Target in left half
            } else {
                left = mid + 1;   // Target in right half
            }
        } else {  // Right half is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;   // Target in right half
            } else {
                right = mid - 1;  // Target in left half
            }
        }
    }
    
    return -1;
}
```

**Explanation:**
- Key insight: At least one half is always fully sorted
- Compare `nums[mid]` with `nums[left]` or `nums[right]` to determine sorted half
- Then check if target lies in sorted half

---

## ðŸŸ¢ Pattern 4 â€” Unknown-Size / Infinite Array

### Sub-pattern: Exponential Search
**When to use:** Array size unknown or infinite

```cpp
// Template 4: Search in Array of Unknown Size
int searchUnknownSize(ArrayReader& reader, int target) {
    // Step 1: Find bounds exponentially
    int left = 0;
    int right = 1;
    
    while (reader.get(right) < target) {
        left = right;
        right = right * 2;  // Exponential expansion
    }
    
    // Step 2: Binary search within bounds
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int val = reader.get(mid);
        
        if (val == target) {
            return mid;
        } else if (val < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

**Explanation:**
- First find boundaries by doubling (exponential search)
- Then perform standard binary search within found bounds
- Handles "infinite" arrays efficiently

---

## ðŸŸ¢ Pattern 5 â€” Matrix Search

### Sub-pattern: 2D to 1D Mapping
**When to use:** Search in row-column sorted matrix

```cpp
// Template 5A: Search in Strictly Sorted Matrix
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    
    int left = 0;
    int right = m * n - 1;  // Treat as 1D array
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int row = mid / n;      // Convert to 2D coordinates
        int col = mid % n;
        
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return false;
}
```

### Sub-pattern: Search in Row/Column Sorted Matrix
**When to use:** Each row and column sorted independently

```cpp
// Template 5B: Search in Sorted Matrix (240)
bool searchMatrixII(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    
    int row = 0;
    int col = n - 1;  // Start from top-right
    
    while (row < m && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] < target) {
            row++;  // Move down (larger)
        } else {
            col--;  // Move left (smaller)
        }
    }
    
    return false;
}
```

**Explanation:**
- Template 5A: Perfect for "74 Search a 2D Matrix" (next row starts > previous row)
- Template 5B: For "240 Search a 2D Matrix II" (only rows and cols sorted individually)

---

## ðŸŸ¢ Pattern 6 â€” Binary Search on Answer

### Sub-pattern: Minimize Maximum
**When to use:** Find smallest feasible value

```cpp
// Template 6A: Minimize Maximum
int minimizeMax(vector<int>& nums, int k) {
    auto can = [&](int mid) -> bool {
        // Check if 'mid' as maximum is feasible
        // Implementation depends on problem
        int count = 0;
        // ... feasibility logic
        return count >= k;  // Or whatever condition
    };
    
    int left = 0;                // Minimum possible answer
    int right = 1e9;             // Maximum possible answer
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (can(mid)) {
            right = mid;  // Try smaller maximum
        } else {
            left = mid + 1;  // Need larger maximum
        }
    }
    
    return left;  // Minimum feasible maximum
}
```

### Sub-pattern: Maximize Minimum
**When to use:** Find largest feasible value

```cpp
// Template 6B: Maximize Minimum
int maximizeMin(vector<int>& nums, int k) {
    auto can = [&](int mid) -> bool {
        // Check if 'mid' as minimum is feasible
        int count = 0;
        // ... feasibility logic
        return count >= k;
    };
    
    int left = 0;
    int right = 1e9;
    int result = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (can(mid)) {
            result = mid;      // Record feasible
            left = mid + 1;    // Try larger minimum
        } else {
            right = mid - 1;   // Need smaller minimum
        }
    }
    
    return result;  // Maximum feasible minimum
}
```

### Sub-pattern: Kth Smallest
**When to use:** Find kth smallest element in unsorted collection

```cpp
// Template 6C: Kth Smallest via Counting
int kthSmallest(vector<vector<int>>& matrix, int k) {
    auto countLessEqual = [&](int mid) -> int {
        // Count elements <= mid
        int count = 0;
        int row = matrix.size() - 1;
        int col = 0;
        
        while (row >= 0 && col < matrix[0].size()) {
            if (matrix[row][col] <= mid) {
                count += row + 1;
                col++;
            } else {
                row--;
            }
        }
        return count;
    };
    
    int left = matrix[0][0];
    int right = matrix.back().back();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (countLessEqual(mid) >= k) {
            right = mid;  // Answer <= mid
        } else {
            left = mid + 1;  // Answer > mid
        }
    }
    
    return left;  // kth smallest element
}
```

**Explanation:**
- **Minimize Maximum**: Binary search on "maximum", find smallest max that works
- **Maximize Minimum**: Binary search on "minimum", find largest min that works  
- **Kth Smallest**: Count how many â‰¤ mid, compare with k
- Key: Always define a monotonic `can()` function

---

## ðŸŸ¢ Pattern 7 â€” Peak / Mountain

### Sub-pattern: Find Peak Element
**When to use:** Array has peak where neighbors are smaller

```cpp
// Template 7: Find Peak Element
int findPeakElement(vector<int>& nums) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] > nums[mid + 1]) {
            // We're in descending part, peak is left
            right = mid;
        } else {
            // We're in ascending part, peak is right
            left = mid + 1;
        }
    }
    
    return left;  // Peak index
}
```

**Explanation:**
- Compare `nums[mid]` with `nums[mid+1]` to determine direction
- Move toward the higher side
- Guaranteed to find a peak (array can have multiple)

---

## ðŸŸ¢ Pattern 8 â€” Two Arrays / Partition

### Sub-pattern: Median of Two Sorted Arrays
**When to use:** Find median of two sorted arrays combined

```cpp
// Template 8: Median of Two Sorted Arrays
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    // Ensure nums1 is smaller
    if (nums1.size() > nums2.size()) {
        return findMedianSortedArrays(nums2, nums1);
    }
    
    int m = nums1.size();
    int n = nums2.size();
    int total = m + n;
    int half = (total + 1) / 2;
    
    int left = 0;
    int right = m;
    
    while (left <= right) {
        int partition1 = left + (right - left) / 2;
        int partition2 = half - partition1;
        
        int left1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];
        int right1 = (partition1 == m) ? INT_MAX : nums1[partition1];
        int left2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];
        int right2 = (partition2 == n) ? INT_MAX : nums2[partition2];
        
        if (left1 <= right2 && left2 <= right1) {
            // Correct partition
            if (total % 2 == 1) {
                return max(left1, left2);  // Odd length
            } else {
                return (max(left1, left2) + min(right1, right2)) / 2.0;  // Even
            }
        } else if (left1 > right2) {
            right = partition1 - 1;  // Move left
        } else {
            left = partition1 + 1;   // Move right
        }
    }
    
    return 0.0;
}
```

**Explanation:**
- Partition arrays so that left half has half the total elements
- Ensure all elements in left half â‰¤ all elements in right half
- Complex but elegant O(log(min(m,n))) solution

---

## ðŸŸ¢ Pattern 9 â€” Specialized / Mathematical

### Sub-pattern: Sqrt(x)
**When to use:** Find integer square root

```cpp
// Template 9A: Square Root
int mySqrt(int x) {
    if (x <= 1) return x;
    
    int left = 1;
    int right = x;
    int result = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (mid <= x / mid) {  // Avoid overflow: mid*mid <= x
            result = mid;       // mid could be answer
            left = mid + 1;     // Try larger
        } else {
            right = mid - 1;    // Too big, try smaller
        }
    }
    
    return result;
}
```

### Sub-pattern: Find Duplicate Number
**When to use:** Find duplicate in array with values 1..n

```cpp
// Template 9B: Find Duplicate Number (Floyd's + Binary Search)
int findDuplicate(vector<int>& nums) {
    int left = 1;
    int right = nums.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        
        // Count numbers <= mid
        for (int num : nums) {
            if (num <= mid) count++;
        }
        
        if (count > mid) {
            right = mid;  // Duplicate in left half
        } else {
            left = mid + 1;  // Duplicate in right half
        }
    }
    
    return left;
}
```

**Explanation:**
- **Sqrt**: Use division to avoid overflow (`mid <= x/mid`)
- **Duplicate**: Count numbers â‰¤ mid, compare with mid (pigeonhole principle)

---

## ðŸŸ¢ Pattern 10 â€” Greedy + Binary Search

### Sub-pattern: Feasibility Check with Greedy
**When to use:** Need to check if a value works using greedy algorithm

```cpp
// Template 10: Greedy + Binary Search (e.g., Koko Eating Bananas)
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        // Binary search on eating speed
        int left = 1;
        int right = *max_element(piles.begin(), piles.end());
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canEatAll(piles, h, mid)) {
                right = mid;  // Try slower speed
            } else {
                left = mid + 1;  // Need faster speed
            }
        }
        
        return left;
    }
    
private:
    bool canEatAll(vector<int>& piles, int h, int speed) {
        int hours = 0;
        for (int pile : piles) {
            hours += (pile + speed - 1) / speed;  // Ceiling division
            if (hours > h) return false;
        }
        return true;
    }
};
```

### Sub-pattern: Ship Packages (Capacity)
```cpp
// Template 10B: Ship Packages Within D Days
int shipWithinDays(vector<int>& weights, int days) {
    auto canShip = [&](int capacity) -> bool {
        int current = 0;
        int daysNeeded = 1;
        
        for (int w : weights) {
            if (current + w > capacity) {
                daysNeeded++;
                current = w;
                if (daysNeeded > days) return false;
            } else {
                current += w;
            }
        }
        return true;
    };
    
    int left = *max_element(weights.begin(), weights.end());
    int right = accumulate(weights.begin(), weights.end(), 0);
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (canShip(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}
```

**Explanation:**
- Greedy algorithm checks feasibility for a given candidate
- Binary search finds optimal candidate
- Common in scheduling, allocation, and partitioning problems

---

## ðŸŸ¢ Decision Function Templates

### When to use which loop condition:

```cpp
// 1. Find exact value
while (left <= right) {
    // Check equality and narrow
}

// 2. Find leftmost valid
while (left < right) {
    // Narrow to single element
    if (valid(mid)) right = mid;
    else left = mid + 1;
}

// 3. Find rightmost valid  
while (left < right) {
    int mid = left + (right - left + 1) / 2;  // Upper mid
    if (valid(mid)) left = mid;
    else right = mid - 1;
}
```

### Mid Calculation Cheat Sheet:

```cpp
// Standard mid (avoids overflow)
int mid = left + (right - left) / 2;

// Upper mid (when left = mid in loop)
int mid = left + (right - left + 1) / 2;

// When to use upper mid:
// - When searching for rightmost valid
// - When left = mid in the valid branch
// - Prevents infinite loops
```

---

### âœ… Summary

| Pattern | Key Insight | Template Type |
|:---|:---|:---|
| Classic | Three-way comparison | `while (left <= right)` |
| Boundaries | First/Last true | `while (left < right)` |
| Rotated | Find sorted half | Compare mid with ends |
| Unknown Size | Exponential bounds | Double right until found |
| Matrix | 2D â†’ 1D mapping | `row = mid/n, col = mid%n` |
| Answer | Monotonic `can()` | Minimize/Maximize |
| Peak | Compare with neighbor | Move toward higher side |
| Partition | Left half condition | Partition indices |
| Specialized | Problem-specific | Math/counting tricks |
| Greedy+BS | Feasibility check | Greedy inside `can()` |

---

Want me to create:
- ðŸ“Œ **Similar templates for Tree patterns?**
- ðŸ“Œ **Binary Search on Answer problem set with decision functions?**
- ðŸ“Œ **Common pitfalls and debugging guide?**

Just ask!
