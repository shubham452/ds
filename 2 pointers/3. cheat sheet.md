Perfect ğŸ‘
Iâ€™ll give you a **clean 1-page printable cheat sheet** (text-only, dense, interview-ready).
You can directly **copy â†’ print â†’ revise before interviews**.

---

# ğŸ§  TWO POINTERS â€” ONE-PAGE CHEAT SHEET

---

## ğŸ”‘ CORE IDEA

> **Use two indices to shrink the search space deterministically**
> Each move must **eliminate impossible answers forever**.

---

## ğŸš¦ FIRST DECISION (ASK THIS FIRST)

1. **Sorted / symmetry / pair?** â†’ Collision
2. **Remove / compress / in-place?** â†’ Fastâ€“Slow
3. **Categories (0/1/2)?** â†’ Partition
4. **Subarray / substring constraint?** â†’ Sliding Window
5. **Merge from back?** â†’ Backward
6. **Linked list structure?** â†’ Fastâ€“Slow (speed)

---

## 1ï¸âƒ£ COLLISION (OPPOSITE DIRECTION)

**Setup**

```
L = 0, R = n-1
```

**Used for**

* Two Sum (sorted)
* 3Sum / 4Sum
* Container With Most Water
* Valid Palindrome
* Trapping Rain Water
* Reverse String

**Movement Rule**

* Sum too small â†’ L++
* Sum too big â†’ R--
* Limiting height â†’ move smaller
* Palindrome mismatch â†’ fail

**Template**

```cpp
while (L < R) {
    if (condition_met) update();
    else if (need_smaller) R--;
    else L++;
}
```

**Mental Line**

> â€œThis end can never help me again.â€

---

## 2ï¸âƒ£ FASTâ€“SLOW (SAME DIRECTION)

**Setup**

```
slow = 0
fast scans
```

**Used for**

* Remove Duplicates
* Remove Element
* Move Zeroes
* Sort by Parity
* String Compression

**Template**

```cpp
int slow = 0;
for (int fast = 0; fast < n; fast++) {
    if (valid(nums[fast])) {
        nums[slow++] = nums[fast];
    }
}
return slow;
```

**Mental Line**

> â€œFast explores, slow builds.â€

---

## 3ï¸âƒ£ PARTITION (DUTCH NATIONAL FLAG)

**Setup**

```
low = 0, mid = 0, high = n-1
```

**Used for**

* Sort Colors
* Separate positives/negatives
* Rearrange by sign
* Separate black & white balls

**Template**

```cpp
while (mid <= high) {
    if (nums[mid] == 0)
        swap(nums[low++], nums[mid++]);
    else if (nums[mid] == 1)
        mid++;
    else
        swap(nums[mid], nums[high--]);
}
```

**Mental Line**

> â€œClassify unknowns into zones.â€

---

## 4ï¸âƒ£ SLIDING WINDOW (BOUNDED TWO POINTERS)

**Setup**

```
L = 0, R expands
```

**Used for**

* Longest / shortest substring
* Count binary substrings
* Window constraints
* Reverse words in string

**Template**

```cpp
int L = 0;
for (int R = 0; R < n; R++) {
    add(R);
    while (invalid()) {
        remove(L);
        L++;
    }
    update_answer();
}
```

**Mental Line**

> â€œExpand to break, shrink to fix.â€

---

## 5ï¸âƒ£ BACKWARD TWO POINTERS

**Setup**

```
i = end of A
j = end of B
k = end of result
```

**Used for**

* Merge Sorted Array
* Squares of Sorted Array
* Next Permutation

**Template**

```cpp
while (i >= 0 && j >= 0)
    nums[k--] = (A[i] > B[j]) ? A[i--] : B[j--];

while (j >= 0) nums[k--] = B[j--];
```

**Mental Line**

> â€œFill where space exists.â€

---

## 6ï¸âƒ£ FASTâ€“SLOW (LINKED LIST)

**Setup**

```
slow = 1x
fast = 2x
```

**Used for**

* Cycle detection
* Find cycle start
* Middle of linked list
* Intersection of lists

**Template**

```cpp
while (fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
    if (slow == fast) return true;
}
return false;
```

**Mental Line**

> â€œFast reveals structure.â€

---

## âš ï¸ COMMON MISTAKES

* Using collision on **unsorted input**
* Forgetting to move pointer â†’ infinite loop
* Skipping duplicates without bounds check
* Using `<` vs `<=` incorrectly

---

## ğŸ§  FINAL GOLDEN RULE

> **If you canâ€™t explain why a pointer move deletes answers, itâ€™s wrong.**

---

If you want next:

* I can **compress this into an A4 PDF**
* Or create **memory triggers** (â€œIf I see X â†’ do Yâ€)
* Or run **pointer-movement drills** (interview style)

Just tell me ğŸ‘
Perfect choice ğŸ‘
These **memory triggers** are what make Two Pointers feel *automatic* in interviews.

Below is a **high-signal trigger map**:
ğŸ‘‰ *If you see X in the problem â†’ your brain must jump to Y immediately.*

---

# ğŸ§  TWO POINTERS â€” MEMORY TRIGGERS (IF X â†’ DO Y)

Memorize this. This is **intuition in compressed form**.

---

## ğŸ”¥ TRIGGER 1: â€œSorted Arrayâ€ + â€œPair / Tripletâ€

**If you see**

* â€œsorted arrayâ€
* â€œpairâ€, â€œtripletâ€, â€œsumâ€, â€œclosestâ€, â€œdifferenceâ€

ğŸ‘‰ **DO THIS**

* Use **Collision Two Pointers**
* Start from **both ends**

**Why**

* Monotonicity lets you discard one side fully

**Examples**

* Two Sum II
* 3Sum
* 4Sum
* 3Sum Closest

ğŸ§  *Auto-thought*:

> â€œOne comparison kills many cases.â€

---

## ğŸ”¥ TRIGGER 2: â€œPalindrome / Symmetry / Reverseâ€

**If you see**

* palindrome
* symmetry
* reverse string/array
* compare from both ends

ğŸ‘‰ **DO THIS**

* Collision pointers
* Compare `L` vs `R`, move inward

**Examples**

* Valid Palindrome
* Reverse String
* Lexicographically Smallest Palindrome

ğŸ§  *Auto-thought*:

> â€œMirror check.â€

---

## ğŸ”¥ TRIGGER 3: â€œMax / Min between two indicesâ€

**If you see**

* â€œmaximum areaâ€
* â€œmin distanceâ€
* width Ã— height
* ends matter more than middle

ğŸ‘‰ **DO THIS**

* Collision pointers
* Move the **limiting side**

**Examples**

* Container With Most Water
* Trapping Rain Water

ğŸ§  *Auto-thought*:

> â€œBottleneck controls everything.â€

---

## ğŸ”¥ TRIGGER 4: â€œRemove / Delete / Compress in-placeâ€

**If you see**

* remove duplicates
* remove element
* in-place
* no extra space
* preserve order

ğŸ‘‰ **DO THIS**

* **Fastâ€“Slow (Writerâ€“Reader)**

**Examples**

* Remove Duplicates
* Move Zeroes
* Remove Element
* String Compression

ğŸ§  *Auto-thought*:

> â€œOne scans, one builds.â€

---

## ğŸ”¥ TRIGGER 5: â€œRearrange by rule (parity / sign / pivot)â€

**If you see**

* even/odd
* positive/negative
* pivot
* reorder by rule

ğŸ‘‰ **DO THIS**

* Fastâ€“Slow OR Partition
* Depends on category count

**Examples**

* Sort by Parity
* Rearrange by Sign
* Partition Array by Pivot

ğŸ§  *Auto-thought*:

> â€œSend valid items forward.â€

---

## ğŸ”¥ TRIGGER 6: â€œOnly 2â€“3 distinct valuesâ€

**If you see**

* only 0,1,2
* red/white/blue
* black/white balls

ğŸ‘‰ **DO THIS**

* **Dutch National Flag (3 pointers)**

**Examples**

* Sort Colors
* Separate Black & White Balls

ğŸ§  *Auto-thought*:

> â€œZones + unknown region.â€

---

## ğŸ”¥ TRIGGER 7: â€œSubarray / Substring + Constraintâ€

**If you see**

* longest / shortest
* at most / at least
* contiguous
* substring

ğŸ‘‰ **DO THIS**

* **Sliding Window**

**Examples**

* Count Binary Substrings
* Reverse Words in String
* Sentence Similarity

ğŸ§  *Auto-thought*:

> â€œExpand â†’ break â†’ shrink.â€

---

## ğŸ”¥ TRIGGER 8: â€œMerge two sorted arraysâ€

**If you see**

* merge sorted
* extra space at end
* overwrite risk

ğŸ‘‰ **DO THIS**

* **Backward Two Pointers**

**Examples**

* Merge Sorted Array
* Squares of Sorted Array

ğŸ§  *Auto-thought*:

> â€œLargest goes last.â€

---

## ğŸ”¥ TRIGGER 9: â€œLinked List + No Extra Spaceâ€

**If you see**

* cycle
* intersection
* middle of list
* no memory allowed

ğŸ‘‰ **DO THIS**

* **Fastâ€“Slow (speed difference)**

**Examples**

* Linked List Cycle
* Intersection of Two Lists

ğŸ§  *Auto-thought*:

> â€œFast reveals structure.â€

---

## ğŸ”¥ TRIGGER 10: â€œCan I kill answers by moving ONE pointer?â€

**If you see**

* single comparison removes many cases

ğŸ‘‰ **DO THIS**

* Two Pointers is correct

ğŸ§  *Auto-thought*:

> â€œEvery move must delete possibilities.â€

---

# ğŸ§  ULTRA-SHORT INTERVIEW VERSION (10 SECONDS)

* Sorted + pair â†’ **Collision**
* Remove / compress â†’ **Fastâ€“Slow**
* 3 values â†’ **Partition**
* Subarray â†’ **Sliding Window**
* Merge sorted â†’ **Backward**
* Linked list â†’ **Fastâ€“Slow**

---

## FINAL CHECK (MOST IMPORTANT)

Before coding, ask yourself:

> **â€œWhich pointer move permanently deletes impossible answers?â€**

If you canâ€™t answer â†’ rethink.

---

If you want next:

* I can turn this into a **flashcard deck**
* Or do **rapid-fire interview drills** (you answer, I correct)
* Or map **each problem â†’ trigger sentence**

Just say the word ğŸ”¥
