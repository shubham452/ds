Perfect â€” this is the **final, cleaned, merged, canonical version**.
No duplication, no confusion. This is the **ONE tree pattern system** you should keep.

Read it once end-to-end. After this, **every tree question will feel familiar**.

---

# ğŸŒ³ THE ONLY BINARY TREE PATTERN SYSTEM YOU NEED

*(Patterns + Sub-patterns + Templates + Golden Rules)*

---

## ğŸ§  HOW EXPERTS THINK (NON-NEGOTIABLE)

Before code, ask **ONLY THESE 6 QUESTIONS**:

1. **What does the problem want?**
   Value? Path? Structure change? Relationship?

2. **Does the parent need information from children?**
   â†’ YES = **Postorder**
   â†’ NO = **Preorder / BFS**

3. **Is information flowing UP or DOWN?**
   UP = return value
   DOWN = pass parameters

4. **Is the answer local or global?**
   Local â†’ return
   Global â†’ reference / class variable

5. **Is distance / level involved?**
   â†’ BFS

6. **Is tree structure changing?**
   â†’ return `TreeNode*`

Thatâ€™s it.
Everything maps cleanly after this.

---

# ğŸŸ¦ PATTERN 1 â€” PURE TRAVERSAL

*(Visit only, no logic)*

### ğŸ§  Identification

Keywords: `traversal`, `print`, `visit`, `order`

### ğŸ”‘ Core idea

> â€œI only need to visit nodes in some order.â€

### ğŸ§± Template

```cpp
void dfs(TreeNode* root) {
    if (!root) return;
    // preorder work
    dfs(root->left);
    // inorder work
    dfs(root->right);
    // postorder work
}
```

### âœ… Examples

* Preorder / Inorder / Postorder
* N-ary traversal
* Morris traversal

### ğŸŸ¡ Golden Rule

**Traversal is the alphabet of trees.**

---

# ğŸŸ¦ PATTERN 2 â€” POSTORDER RETURN (BOTTOM-UP)

### ğŸ§  Identification

Keywords: `height`, `depth`, `diameter`, `balanced`, `max`, `min`, `count`

### ğŸ”‘ Core idea

> **Parent decision depends on children.**

### ğŸ§± Universal Template

```cpp
int dfs(TreeNode* root) {
    if (!root) return BASE;
    int left = dfs(root->left);
    int right = dfs(root->right);
    return combine(left, right);
}
```

### ğŸ”¹ Sub-patterns

#### 2A â€” Return only

* Height
* Size
* Max depth

#### 2B â€” Return + global

* Diameter
* Max subtree sum

```cpp
ans = max(ans, left + right);
return 1 + max(left, right);
```

### ğŸŸ¡ Golden Rule

**If children matter â†’ POSTORDER.**

---

# ğŸŸ¦ PATTERN 3 â€” PATH PROBLEMS (MOST IMPORTANT)

> **Paths are LINEAR. They do NOT fork upward.**

---

## ğŸ”¹ PATTERN 3A â€” ROOT â†’ LEAF (TOP-DOWN)

### ğŸ§  Identification

Keywords: `root to leaf`, `all paths`, `sum`, `string`

### ğŸ§± Template

```cpp
void dfs(TreeNode* root, Path path) {
    if (!root) return;
    update(path);
    if (leaf) store(path);
    dfs(root->left, path);
    dfs(root->right, path);
}
```

### âœ… Examples

* Binary Tree Paths
* Path Sum I / II
* Root to Leaf Numbers

### ğŸŸ¡ Golden Rule

**Carry info DOWN, store at leaf.**

---

## ğŸ”¹ PATTERN 3B â€” ANY â†’ ANY (GLOBAL ANSWER)

### ğŸ§  Identification

Keywords: `maximum`, `any node`, `path sum`, `diameter`

### ğŸ§± Template

```cpp
int dfs(TreeNode* root) {
    int left = max(0, dfs(root->left));
    int right = max(0, dfs(root->right));

    ans = max(ans, root->val + left + right); // fork allowed
    return root->val + max(left, right);      // fork NOT allowed
}
```

### ğŸŸ¡ Golden Rule

**Update global with two paths, return ONE.**

---

## ğŸ”¹ PATTERN 3C â€” COUNTING PATHS (PREFIX SUM)

### ğŸ§  Identification

Keywords: `count paths`, `target sum anywhere`

### ğŸ§± Template (idea)

```cpp
prefixSum + DFS + backtracking
```

### âœ… Example

* Path Sum III

### ğŸŸ¡ Golden Rule

**Counting â‰  max. Use prefix sums.**

---

# ğŸŸ¦ PATTERN 4 â€” BFS / LEVEL / DISTANCE

---

## ğŸ”¹ PATTERN 4A â€” LEVEL ORDER / VIEWS

### ğŸ§  Identification

Keywords: `level`, `view`, `average`, `zigzag`

### ğŸ§± Template

```cpp
queue<TreeNode*> q;
while (!q.empty()) {
    int size = q.size();
    for (int i = 0; i < size; i++) {
        process node
        push children
    }
}
```

### âœ… Examples

* Level order
* Zigzag
* Left / Right view
* Average of levels
* Min depth (best with BFS)

### ğŸŸ¡ Golden Rule

**Levels â†’ Queue.**

---

## ğŸ”¹ PATTERN 4B â€” DISTANCE FROM TARGET (TREE â†’ GRAPH)

### ğŸ§  Identification

Keywords: `distance k`, `from target`, `time`, `burn`

### ğŸ§± Template

```cpp
map parent
BFS from target
visited set
```

### âœ… Examples

* Nodes at distance K
* Burning Tree
* Time to infect tree

### ğŸŸ¡ Golden Rule

**Distance from non-root â†’ parent map.**

---

# ğŸŸ¦ PATTERN 5 â€” HORIZONTAL / VERTICAL VIEW

### ğŸ§  Identification

Keywords: `top view`, `bottom view`, `vertical`

### ğŸ§± Template

```cpp
queue<pair<Node*, hd>>
map<hd, data>
```

### âœ… Examples

* Top View
* Bottom View
* Vertical Order
* Vertical Sum

### ğŸŸ¡ Golden Rule

**Position matters â†’ horizontal distance.**

---

# ğŸŸ¦ PATTERN 6 â€” STRUCTURAL MODIFICATION

### ğŸ§  Identification

Keywords: `remove`, `invert`, `flatten`, `merge`

### ğŸ”‘ Core idea

> Return **new subtree root**.

### ğŸ§± Template

```cpp
TreeNode* dfs(TreeNode* root) {
    if (!root) return nullptr;
    root->left = dfs(root->left);
    root->right = dfs(root->right);
    return root; // or modified root
}
```

### âœ… Examples

* Remove Half Nodes
* Invert Tree
* Prune Tree
* Flatten Binary Tree

### ğŸŸ¡ Golden Rule

**If tree changes â†’ return TreeNode*.**

---

# ğŸŸ¦ PATTERN 7 â€” TREE CONSTRUCTION / SERIALIZATION

### ğŸ§  Identification

Keywords: `build`, `construct`, `serialize`

### ğŸ”‘ Core idea

> Traversals define structure.

| Traversal | Root  |
| --------- | ----- |
| Preorder  | First |
| Postorder | Last  |
| Inorder   | Split |

### âœ… Examples

* Build from In + Pre
* Serialize / Deserialize

### ğŸŸ¡ Golden Rule

**Find root â†’ split â†’ recurse.**

---

# ğŸŸ¦ PATTERN 8 â€” TWO TREE COMPARISON / VALIDATION

### ğŸ§  Identification

Keywords: `same`, `mirror`, `symmetric`, `validate`

### ğŸ§± Template

```cpp
bool dfs(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return check &&
           dfs(a->left, b->left) &&
           dfs(a->right, b->right);
}
```

### âœ… Examples

* Same Tree
* Symmetric Tree
* Validate BST
* Subtree of another tree

### ğŸŸ¡ Golden Rule

**Compare in sync.**

---

# ğŸŸ¦ PATTERN 9 â€” BST-SPECIFIC

### ğŸ§  Identification

Keywords: `BST`, `sorted`, `range`, `kth`

### ğŸ”‘ Core ideas

* Inorder = sorted
* Left < Root < Right

### âœ… Examples

* Kth smallest
* LCA in BST
* Validate BST

### ğŸŸ¡ Golden Rule

**Use ordering, not brute DFS.**

---

# ğŸŸ¦ PATTERN 10 â€” N-ARY TREES

### ğŸ§  Identification

Keywords: `children list`

### ğŸ§± Template

```cpp
for (auto child : node->children)
    dfs(child);
```

### ğŸŸ¡ Golden Rule

**Same patterns, loop over children.**

---

# ğŸ§­ MASTER DECISION FLOW (MEMORIZE)

```
Traversal only? â†’ Pattern 1
Children dependent? â†’ Pattern 2
Path mentioned? â†’ Pattern 3
Level / distance? â†’ Pattern 4
Horizontal view? â†’ Pattern 5
Structure change? â†’ Pattern 6
Build tree? â†’ Pattern 7
Compare trees? â†’ Pattern 8
BST rules apply? â†’ Pattern 9
```

---

# ğŸ”’ FINAL GOLDEN TRUTHS

* **There are ONLY ~10 tree patterns**
* **All questions are variations**
* **Recursion is signal passing, not magic**
* **If you know what DFS returns, you know the solution**

---

## ğŸ WHAT TO DO NEXT (RECOMMENDED)

If you want, next I can:

1. ğŸ“„ Create a **1-page printable PDF cheat sheet**
2. ğŸ§© Map **LeetCode tree problems â†’ patterns**
3. ğŸ† Give **company-wise frequency**
4. ğŸ§  Do **rapid pattern classification drills**
5. ğŸ¯ Build **one universal recursion template**

Just tell me what you want next ğŸ‘Š
