Excellent â€” **Pattern 4 is where many people get confused**, so letâ€™s build this **cleanly, slowly, and correctly**.

Iâ€™ll teach you **like a teacher**, not a reference book.

Weâ€™ll go in **this exact order**:

1. What Pattern 4 *really* is
2. How to **identify** Pattern 4 in 5 seconds
3. Why Pattern 4 splits into **4A and 4B**
4. Deep intuition + templates for **each sub-pattern**
5. A **step-by-step solving checklist** you can reuse

---

# ğŸŸ¦ PATTERN 4 â€” BFS / LEVEL / DISTANCE

*(Breadth-First Thinking)*

---

## ğŸ§  WHAT THIS PATTERN REALLY IS

**Pattern 4 is about DISTANCE, not depth.**

DFS answers:

> â€œHow deep can I go?â€

BFS answers:

> â€œHow far is this node from something?â€

ğŸ“Œ This single difference explains **why BFS exists**.

---

## ğŸ§  CORE IDEA (ONE LINE)

> **If the problem talks about levels, distance, time, or views â†’ think BFS.**

---

## ğŸ§  HOW TO IDENTIFY PATTERN 4 (VERY IMPORTANT)

Before coding, ask:

### â“ Does the problem mention:

* level
* depth by level
* distance
* time / burn / spread
* view (left, right, top)
* nearest / minimum steps

ğŸ‘‰ If YES â†’ **Pattern 4**

Then ask ONE more question:

> â“ Is the distance measured from the ROOT or from a GIVEN NODE?

This splits the pattern.

---

# ğŸ”¹ PATTERN 4A â€” LEVEL ORDER / VIEWS

*(Root-based BFS)*

---

## ğŸ§  WHAT THESE PROBLEMS MEAN

> â€œProcess nodes **level by level** starting from the root.â€

Distance = number of edges from **root**.

---

## ğŸ§  IDENTIFICATION RULE (LOCK THIS)

If the problem says:

* **level**
* **average of levels**
* **zigzag**
* **left / right view**
* **minimum depth**

ğŸ‘‰ This is **4A**

---

## ğŸ§  INTUITION (IMPORTANT)

BFS processes:

```
level 0 â†’ level 1 â†’ level 2 â†’ ...
```

So naturally:

* One loop = one level
* Queue size tells you how many nodes are on that level

---

## ğŸ§± UNIVERSAL TEMPLATE (MEMORIZE)

```cpp
queue<TreeNode*> q;
q.push(root);

while (!q.empty()) {
    int size = q.size();     // nodes in this level

    for (int i = 0; i < size; i++) {
        TreeNode* node = q.front();
        q.pop();

        process(node);

        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }

    // level finished
}
```

ğŸ“Œ This template solves **80% of BFS tree problems**.

---

## ğŸŸ¡ GOLDEN RULE

> **Levels â†’ Queue â†’ size loop**

---

## ğŸ§  HOW VARIATIONS FIT INTO SAME TEMPLATE

| Problem     | What changes                   |
| ----------- | ------------------------------ |
| Level Order | store all nodes                |
| Zigzag      | reverse order every level      |
| Left View   | take first node of each level  |
| Right View  | take last node                 |
| Average     | sum / count                    |
| Min Depth   | return when first leaf appears |

ğŸš¨ **Template NEVER changes**
Only **what you do inside `process()`** changes.

---

## âŒ COMMON MISTAKES IN 4A

âŒ Using DFS for min depth
âŒ Forgetting `size = q.size()`
âŒ Mixing levels
âŒ Not stopping early (min depth)

---

# ğŸ”¹ PATTERN 4B â€” DISTANCE FROM TARGET (TREE â†’ GRAPH)

---

## ğŸ§  WHAT THESE PROBLEMS MEAN

> â€œStart from a GIVEN node, not the root.â€

Examples:

* Nodes at distance K from target
* Burning Tree
* Time to infect tree

ğŸ“Œ **Trees donâ€™t have parent pointers**, so BFS alone is not enough.

---

## ğŸ§  IDENTIFICATION RULE

If the problem says:

* distance **from target**
* time to spread
* burn from a node
* nearest node to X

ğŸ‘‰ This is **4B**

---

## ğŸ§  THE BIG MENTAL SHIFT (VERY IMPORTANT)

You must think:

> **Tree â†’ Undirected Graph**

Why?
Because fire / infection / distance spreads:

* left
* right
* **upward (parent)**

---

## ğŸ§  STEPS TO SOLVE 4B (ALWAYS SAME)

### Step 1 â€” Build parent map

So every node knows its parent.

```cpp
map<Node*, Node*> parent;
```

---

### Step 2 â€” BFS from target

Now treat it like graph BFS.

---

### Step 3 â€” Use visited set

Prevent going back and forth.

---

## ğŸ§± UNIVERSAL TEMPLATE (MENTAL)

```cpp
build parent map using DFS/BFS

queue starting with target
visited.insert(target)

while queue not empty:
    for nodes in this level:
        go to left, right, parent if not visited
    increment distance / time
```

---

## ğŸŸ¡ GOLDEN RULE

> **Distance from non-root â†’ parent map required**

---

## âŒ COMMON MISTAKES IN 4B

âŒ Forgetting parent traversal
âŒ No visited set â†’ infinite loop
âŒ Starting BFS from root instead of target
âŒ Treating it like normal level order

---

# ğŸ§  HOW TO CHOOSE 4A vs 4B (FAST)

Ask **ONLY THIS**:

> â“ Is the distance measured from ROOT or from a GIVEN NODE?

| Answer | Pattern |
| ------ | ------- |
| Root   | 4A      |
| Target | 4B      |

No overlap.

---

# ğŸ§­ INTERVIEW CHECKLIST (USE THIS LIVE)

Before coding, ask:

1. Is this level / distance / time based?
2. Is BFS more natural than DFS?
3. Do I need parent pointers?
4. When do I stop BFS?
5. What defines one â€œstepâ€ or â€œtime unitâ€?

If you answer these â†’ solution is obvious.

---

# ğŸ”’ FINAL MEMORY LOCK ğŸ”

> **DFS = depth**
> **BFS = distance**

And:

> **Distance from target = tree â†’ graph**

Repeat this. It will save you every time.

---

## ğŸ WHAT SHOULD YOU PRACTICE NEXT

To master Pattern 4, solve in this order:

1. Level Order Traversal
2. Left / Right View
3. Minimum Depth
4. Nodes at Distance K
5. Burning Tree

If you want, next I can:

* Dry-run **Nodes at Distance K** step by step
* Compare **DFS vs BFS** on same problem
* Give you a **Pattern-4 cheat sheet**

