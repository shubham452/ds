Excellent ‚Äî **Pattern 6 is the point where recursion becomes ‚Äúreal‚Äù**, because now you‚Äôre not just computing values, you‚Äôre **rewiring the tree**.

I‚Äôll explain this **slowly and cleanly**, exactly like a teacher would.

---

# üü¶ PATTERN 6 ‚Äî STRUCTURAL MODIFICATION

*(Changing the Tree Itself)*

---

## üß† WHAT THIS PATTERN REALLY IS

Pattern 6 problems are **not asking for an answer value**.

They are asking you to **change the tree structure** and return the **new root**.

> You are no longer *observing* the tree
> You are **mutating** it

---

## üß† CORE IDEA (ONE LINE)

> **If the tree‚Äôs structure changes, recursion must return a `TreeNode*`.**

This is the single most important sentence of Pattern 6.

---

## üß† HOW TO IDENTIFY PATTERN 6 (VERY IMPORTANT)

Before thinking of DFS/BFS, ask:

### ‚ùì Does the problem say:

* remove nodes
* delete nodes
* invert / mirror
* flatten
* prune
* merge trees
* modify structure

üëâ If YES ‚Üí **Pattern 6**

---

## üß† WHY RETURNING `TreeNode*` IS REQUIRED

Imagine this node:

```
    A
   /
  B
```

If `B` is removed, **what should A‚Äôs left point to?**

Answer:

> Whatever the recursive call returns.

üìå That‚Äôs why recursion must **return the new subtree root**.

---

# üß± UNIVERSAL TEMPLATE (MEMORIZE THIS)

This template applies to **every Pattern 6 problem**.

```cpp
TreeNode* dfs(TreeNode* root) {
    if (!root) return nullptr;

    root->left = dfs(root->left);
    root->right = dfs(root->right);

    // decide what to keep / remove / modify

    return root;   // or modified root
}
```

üìå This is **postorder** because:

* Children must be fixed before parent decides

---

# üîπ SUB-PATTERNS OF PATTERN 6

Pattern 6 has **four major sub-patterns**.

---

## üîπ PATTERN 6A ‚Äî REMOVE / PRUNE NODES

### üß† Meaning

> Delete nodes based on a condition.

### Examples

* Remove Half Nodes
* Prune Tree (remove subtrees with sum < k)
* Remove nodes with one child

---

### üß† THINKING MODEL

At each node, ask:

> ‚ÄúShould this node exist after modification?‚Äù

If NO ‚Üí return replacement child or `nullptr`.

---

### üß± Template (Mental)

```cpp
root->left = dfs(root->left)
root->right = dfs(root->right)

if (condition to remove root):
    return nullptr or child

return root
```

---

### üü° Golden Rule

> **Deletion = return `nullptr` or replacement node**

---

## üîπ PATTERN 6B ‚Äî INVERT / MIRROR TREE

### üß† Meaning

> Swap left and right subtrees.

### Example

* Invert Binary Tree
* Mirror Tree

---

### üß† THINKING MODEL

You don‚Äôt delete nodes, you **swap pointers**.

---

### üß± Template

```cpp
TreeNode* dfs(root):
    if (!root) return nullptr

    TreeNode* left = dfs(root->left)
    TreeNode* right = dfs(root->right)

    root->left = right
    root->right = left

    return root
```

---

### üü° Golden Rule

> **Invert = swap after fixing children**

---

## üîπ PATTERN 6C ‚Äî MERGE TWO TREES

### üß† Meaning

> Combine two trees into one.

### Example

* Merge Two Binary Trees

---

### üß† THINKING MODEL

At each position:

* If both nodes exist ‚Üí merge values
* If one exists ‚Üí return it

---

### üß± Template

```cpp
TreeNode* dfs(a, b):
    if (!a) return b
    if (!b) return a

    a->val += b->val
    a->left = dfs(a->left, b->left)
    a->right = dfs(a->right, b->right)

    return a
```

---

### üü° Golden Rule

> **Merge = parallel recursion**

---

## üîπ PATTERN 6D ‚Äî FLATTEN TREE

### üß† Meaning

> Convert tree into linked list.

### Example

* Flatten Binary Tree to Linked List

---

### üß† THINKING MODEL

You must:

* Flatten left
* Flatten right
* Attach left list in between

---

### üß± Template (Conceptual)

```cpp
flatten(left)
flatten(right)

attach left subtree between root and right subtree
```

---

### üü° Golden Rule

> **Flatten = reorder pointers carefully**

---

# üß† HOW TO SOLVE ANY PATTERN-6 PROBLEM (STEP-BY-STEP)

Use this **exact checklist**:

1. Does the tree structure change? ‚Üí YES
2. Should recursion return `TreeNode*`? ‚Üí YES
3. Do children need fixing first? ‚Üí YES (postorder)
4. Should node be removed / swapped / merged?
5. What do I return to parent?

If you answer these, solution writes itself.

---

# üß≠ INTERVIEW IDENTIFICATION FLOW

Ask:

```
Is output a tree?
        ‚Üì
      YES
Is structure modified?
        ‚Üì
      YES ‚Üí Pattern 6
```

---

## ‚ùå COMMON MISTAKES (AVOID THESE)

‚ùå Returning `int` instead of `TreeNode*`
‚ùå Modifying before recursion
‚ùå Forgetting to reattach children
‚ùå Returning wrong node after deletion

---

## üîí FINAL MEMORY LOCK üîê

Repeat this:

> **If the tree changes, recursion returns a node.**

This sentence alone is enough.

---

## üèÅ WHAT TO PRACTICE NEXT

Best order:

1. Invert Binary Tree
2. Remove Half Nodes
3. Merge Two Binary Trees
4. Prune Tree

If you want next, I can:

* Dry-run **Remove Half Nodes**
* Show **Flatten Tree pointer rewiring**
* Give a **Pattern 6 cheat sheet**


