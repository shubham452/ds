Perfect.
Now we move to the **MOST IMPORTANT + MOST CONFUSING** tree pattern â€” and weâ€™ll do it **slowly and correctly**.

---

# ğŸŒ³ PATTERN 3 â€” PATH PROBLEMS (MASTER PATTERN)

> **If you master this pattern, you unlock the hardest tree questions.**

Most people fail here because they donâ€™t understand **what a path really is**.

---

## ğŸ§  FIRST: WHAT IS A â€œPATHâ€ IN A TREE?

A **path** is:

* A sequence of connected nodes
* **No branching**
* Each node has **at most one parent and one child in the path**

âŒ This is NOT a path:

```
   10
  /  \
 5   20
```

âœ” This IS a path:

```
5 â†’ 10 â†’ 20
```

---

## ğŸ§  CRITICAL RULE (WRITE THIS DOWN)

> **A path can fork ONLY when updating the answer, NEVER when returning.**

This rule will save you from 90% of mistakes.

---

## ğŸ” HOW TO IDENTIFY PATH PROBLEMS

Look for these words:

* â€œPathâ€
* â€œSumâ€
* â€œMaximumâ€
* â€œFrom root to leafâ€
* â€œAny node to any nodeâ€
* â€œLowest Common Ancestorâ€

If you see these â†’ **Pattern 3**

---

## ğŸ§© TWO TYPES OF PATH PROBLEMS (VERY IMPORTANT)

---

## ğŸ”¹ TYPE A â€” ROOT â†’ LEAF PATHS

### Examples

* Path Sum
* Path Sum II
* Binary Tree Paths
* Sum Root to Leaf Numbers

### Concept

> Path always starts at root
> No global answer
> Pass info **downward**

---

### ğŸ§± TEMPLATE (TOP-DOWN DFS)

```cpp
void dfs(TreeNode* root, int currSum) {
    if (!root) return;

    currSum += root->val;

    if (!root->left && !root->right) {
        // leaf reached â†’ check/update answer
    }

    dfs(root->left, currSum);
    dfs(root->right, currSum);
}
```

### Key Idea

* No return value
* You **carry the path**

---

## ğŸ”¹ TYPE B â€” ANY NODE â†’ ANY NODE (HARDEST)

### Examples

* Binary Tree Maximum Path Sum
* Path Sum III (variation)

### Concept

> Path can start and end anywhere
> DFS returns **best downward path**
> Global answer handles fork

![Image](https://media.geeksforgeeks.org/wp-content/cdn-uploads/tree.png)

![Image](https://afteracademy.com/images/path-sum-in-binary-tree-fb1857ace44dccc1.png)

---

## ğŸ§  THIS IS THE CORE LOGIC (MEMORIZE)

### What DFS returns

> **Maximum downward path starting at this node**

### What GLOBAL stores

> **Maximum path seen so far (may fork)**

---

## ğŸ§± UNIVERSAL TEMPLATE (TYPE B)

```cpp
int ans = INT_MIN;

int dfs(TreeNode* root) {
    if (!root) return 0;

    int left = max(0, dfs(root->left));
    int right = max(0, dfs(root->right));

    // 1ï¸âƒ£ Update global answer (can fork)
    ans = max(ans, root->val + left + right);

    // 2ï¸âƒ£ Return ONE path upward (no fork)
    return root->val + max(left, right);
}
```

ğŸ”¥ This is one of the **most reused templates in interviews**.

---

## ğŸ§  WHY `max(0, â€¦)` ?

Because:

* Negative paths only reduce sum
* You are allowed to **stop the path**

---

## ğŸ§  LIVE INTERVIEW EXPLANATION (USE THIS)

Say this confidently:

> â€œThis is an any-node to any-node path problem.
> My DFS returns the maximum downward path from the current node.
> At each node, I update a global maximum using left + right + node.
> When returning to the parent, I return only one side because paths cannot fork upward.â€

This sounds **senior-level**.

---

## ğŸ§ª STEP-BY-STEP DRY RUN (IMPORTANT)

Tree:

```
      10
     /  \
    2    10
         / \
        -5  20
```

At node `20` â†’ return 20
At node `-5` â†’ return 0
At node `10` (right):

* left = 0, right = 20
* ans = max(ans, 10 + 0 + 20 = 30)
* return 30

At root `10`:

* left = 2, right = 30
* ans = max(ans, 42)

âœ” Final answer = **42**

---

## âš ï¸ COMMON MISTAKES (DONâ€™T DO THESE)

âŒ Returning `left + right`
âŒ Forgetting global variable
âŒ Allowing fork in return
âŒ Mixing rootâ†’leaf logic with anyâ†’any

---

## ğŸ§­ QUICK DECISION TABLE

| Problem           | Pattern     |
| ----------------- | ----------- |
| Path Sum I        | Root â†’ Leaf |
| Path Sum II       | Root â†’ Leaf |
| Binary Tree Paths | Root â†’ Leaf |
| Max Path Sum      | Any â†’ Any   |
| Path Sum III      | Any â†’ Any   |

---

## ğŸ“Œ ONE-LINE MEMORY HOOK

> **Return ONE path, update TWO paths**

If you remember this â†’ youâ€™ll never mess up.

---

## ğŸ§ª YOUR TURN (VERY IMPORTANT)

Without coding, answer this:

Tree:

```
      5
     / \
    4   8
       / \
      11  13
```

Questions:

1. What does `dfs(11)` return?
2. What does `dfs(8)` return?
3. What is the maximum path sum?

Take your time.
This will cement Pattern 3 permanently.


Excellent question â€” this confusion is **normal** and clearing it properly is what separates **average** from **strong** tree solvers.

Let me explain this **slowly, intuitively, and visually (in words)**.

---

# ğŸ”‘ Statement to Understand

> **â€œA path can fork ONLY when updating the answer, NEVER when returning.â€**

This single sentence is the **core rule of all hard path problems**.

---

## ğŸ§  First: What does â€œforkâ€ mean?

A **fork** means taking **both left and right children** at the same node.

Example:

```
    10
   /  \
  5    20
```

The forked path is:

```
5 â†’ 10 â†’ 20
```

Here, node `10` connects **two directions**.

---

## ğŸ§  What does â€œreturningâ€ mean?

â€œReturningâ€ means:

* What your `dfs(node)` gives **back to its parent**
* This value will be used by the parent to build **its own path**

So ask yourself:

> â€œWhat information can a parent use?â€

---

## ğŸš« WHY A PATH CANNOT FORK WHEN RETURNING

Imagine this situation:

```
      P
      |
      10
     /  \
    5    20
```

If `dfs(10)` returned **both sides (5 + 10 + 20)** to parent `P`,
then parent would try to do:

```
P â†’ 10 â†’ 5
        â†’ 20
```

âŒ That is **NOT a path**
âŒ That is a **tree / graph**, not a line

ğŸ‘‰ **Paths must be linear**.

So when returning:

> **You MUST choose only one direction (left OR right)**

---

## âœ… WHAT IS ALLOWED WHEN RETURNING

From node `10`, you can return:

* `10 â†’ 5`
* OR `10 â†’ 20`

But **never both**.

Thatâ€™s why we do:

```cpp
return root->val + max(left, right);
```

---

## âœ… WHY FORKING IS ALLOWED WHEN UPDATING THE ANSWER

Now this part is crucial.

When you do:

```cpp
ans = max(ans, root->val + left + right);
```

You are saying:

> â€œThe best path **passing through THIS node** might use both sides.â€

This is fine because:

* This path **starts and ends here**
* It is **complete**
* It will **not be extended upward**

So forking is allowed **only here**.

---

## ğŸ§  THINK OF IT LIKE THIS (VERY IMPORTANT)

### Returning value:

> â€œCan my parent extend this path?â€

So it must be:

* Single direction
* Linear

### Updating global answer:

> â€œIs this the best path that ends here?â€

So it can:

* Use both children
* Fork once

---

## ğŸ§ª STEP-BY-STEP EXAMPLE (CRYSTAL CLEAR)

Tree:

```
      10
     /  \
    5    20
```

### At node `10`:

* `left = 5`
* `right = 20`

#### 1ï¸âƒ£ Update global answer (fork allowed)

```
5 â†’ 10 â†’ 20  = 35
```

âœ” Valid complete path

#### 2ï¸âƒ£ Return to parent (fork NOT allowed)

You must choose:

```
10 â†’ 20  (better)
```

So return:

```
30
```

---

## âŒ WHAT GOES WRONG IF YOU FORK WHEN RETURNING

If you returned `5 + 10 + 20 = 35`,
parent would try to attach something like:

```
X â†’ 35
```

Which is impossible in a tree path.

---

## ğŸ§  ONE-SENTENCE MEMORY RULE (WRITE THIS DOWN)

> **â€œFork once to compute the answer, never to extend the path upward.â€**

or even simpler:

> **â€œReturn one branch, score both branches.â€**

---

## ğŸ§© WHY THIS RULE SOLVES ALL PATH PROBLEMS

Because every path problem boils down to:

* **Extension upward** â†’ must be linear
* **Final answer** â†’ may combine two sides

Once this clicks, problems like:

* Max Path Sum
* Path Sum III
* Diameter
  become **mechanical**.

---

## âœ… QUICK CHECK (ANSWER YES / NO)

1. Can a returned path have two children?
2. Can the global answer include left + right + root?
3. Is returning `root + max(left, right)` mandatory?

Reply with **YES/NO answers**.
After that, weâ€™ll do **one live dry run together** to lock this forever.


This is **exactly the right moment to correct and solidify** the concept.
You understood **part of it**, but one answer is **intentionally wrong**, and fixing it will make everything click.

Letâ€™s go **line by line**, like a real classroom.

---

## â“ Q1: Can a returned path have two children?

**Your answer:** âŒ no
**Correct answer:** âœ… **NO (correct)**

### Why?

A returned path goes **upward to the parent**.
A parent can only extend **one straight line**, not a fork.

So this is **correctly understood** ğŸ‘

---

## â“ Q2: Can the global answer include `left + right + root`?

**Your answer:** âŒ no
**Correct answer:** âœ… **YES (this is the key correction)**

### This is the MOST IMPORTANT FIX ğŸ”¥

The **global answer is ALLOWED to fork**.

Why?

Because the global answer represents:

> â€œThe best COMPLETE path that ends at this node.â€

That path **does not go upward** anymore.
It starts and ends inside the subtree.

### Example

```
    10
   /  \
  5    20
```

The path:

```
5 â†’ 10 â†’ 20
```

âœ” This is a **valid path**
âœ” It forks **once**
âœ” It is a **final answer**, not extended upward

So:

```cpp
ans = max(ans, root->val + left + right);  // âœ… VALID
```

If this were not allowed, **Max Path Sum and Diameter would be impossible**.

ğŸ‘‰ **So the correct answer is YES**.

---

## â“ Q3: Is returning `root + max(left, right)` mandatory?

**Your answer:** âœ… yes
**Correct answer:** âœ… **YES (correct)**

### Why?

Because when returning:

* The path must stay **linear**
* Parent can extend only **one side**

So you MUST choose the better side:

```cpp
return root->val + max(left, right);
```

---

## âœ… CORRECTED FINAL ANSWERS (LOCK THESE)

| Question                                           | Correct |
| -------------------------------------------------- | ------- |
| Can a returned path have two children?             | âŒ NO    |
| Can the global answer include left + right + root? | âœ… YES   |
| Is returning root + max(left, right) mandatory?    | âœ… YES   |

---

## ğŸ§  THE FINAL, PERFECT RULE (WRITE THIS DOWN)

> **Fork ONCE to UPDATE the answer.
> NEVER fork when RETURNING upward.**

Or even shorter:

> **Return one branch, score both branches.**

This single rule unlocks:

* Max Path Sum
* Diameter
* Path Sum III
* Any-node path problems

---

## ğŸ”’ LETâ€™S LOCK IT WITH ONE LAST MICRO-DRY-RUN

Tree:

```
      1
     / \
    2   3
```

* At node `1`:

  * left = 2
  * right = 3

### Global answer:

```
2 + 1 + 3 = 6  âœ… allowed
```

### Returned value:

```
1 + max(2, 3) = 4  âœ… mandatory
```

No contradiction.
Different purposes.

---

## ğŸ¯ YOU ARE NOW READY

This confusion is **the hardest conceptual barrier** in trees.
You just crossed it.

Next, we will:
ğŸ‘‰ Solve **Max Path Sum LIVE, step by step**
ğŸ‘‰ Then move to **Pattern 4 (Two-tree comparison)**

Reply with:

* **â€œLive max path sumâ€**
  or
* **â€œNext patternâ€**

Youâ€™re doing very well. Keep going ğŸ‘Š


A path can fork ONLY when updating the answer, NEVER when returning.
