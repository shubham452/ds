Perfect timing.
These are your **clean, interview-ready notes for TEMPLATE / PATTERN 2**.
You can revise this **the night before interviews** and feel confident.

Iâ€™ll keep it **structured, crisp, and deep** â€” no fluff.

---

# ğŸŒ³ PATTERN 2 â€” HEIGHT / DEPTH / POSTORDER RETURN

*(Bottom-Up DFS Template)*

---

## ğŸ§  CORE IDEA (ONE LINE)

> **If a node needs information from its children, use POSTORDER DFS and RETURN a value.**

This single sentence unlocks **half of tree DSA**.

---

## ğŸ” HOW TO IDENTIFY THIS PATTERN

A problem belongs to **Template 2** if it asks for:

* Height / Depth
* Maximum / Minimum
* Longest / Largest
* Diameter
* Balanced tree
* Size of tree or subtree

### ğŸ”‘ Keywords to watch

`height`, `depth`, `longest`, `diameter`, `balanced`, `max`, `min`, `count`

---

## ğŸ§± UNIVERSAL TEMPLATE (MEMORIZE)

```cpp
ReturnType dfs(TreeNode* root) {
    if (!root) return BASE_VALUE;

    auto left = dfs(root->left);
    auto right = dfs(root->right);

    // combine children information

    return VALUE_FOR_PARENT;
}
```

Everything else is **just customization**.

---

## ğŸ§  WHY POSTORDER?

Because:

* Parent cannot decide
* Until children report back

So:

```
LEFT â†’ RIGHT â†’ NODE
```

---

## ğŸ”¹ MOST COMMON VARIANTS (WITH MINI TEMPLATES)

---

### 1ï¸âƒ£ Maximum Depth / Height

```cpp
int dfs(TreeNode* root) {
    if (!root) return 0;
    return 1 + max(dfs(root->left), dfs(root->right));
}
```

âœ” Base = 0
âœ” Return = height

---

### 2ï¸âƒ£ Minimum Depth

```cpp
int dfs(TreeNode* root) {
    if (!root) return 0;

    if (!root->left) return 1 + dfs(root->right);
    if (!root->right) return 1 + dfs(root->left);

    return 1 + min(dfs(root->left), dfs(root->right));
}
```

âš  Special handling for single child

---

### 3ï¸âƒ£ Diameter of Binary Tree

```cpp
int ans = 0;

int dfs(TreeNode* root) {
    if (!root) return 0;

    int left = dfs(root->left);
    int right = dfs(root->right);

    ans = max(ans, left + right);
    return 1 + max(left, right);
}
```

âœ” Return height
âœ” Update global answer

---

### 4ï¸âƒ£ Balanced Binary Tree

```cpp
pair<bool,int> dfs(TreeNode* root) {
    if (!root) return {true, 0};

    auto L = dfs(root->left);
    auto R = dfs(root->right);

    bool balanced = L.first && R.first &&
                    abs(L.second - R.second) <= 1;

    return {balanced, 1 + max(L.second, R.second)};
}
```

âœ” Return **two things**
âœ” Still postorder

---

### 5ï¸âƒ£ Count Nodes / Size of Tree

```cpp
int dfs(TreeNode* root) {
    if (!root) return 0;
    return 1 + dfs(root->left) + dfs(root->right);
}
```

---

## ğŸ§  MENTAL CHECKLIST (USE LIVE)

Before coding, ask:

1. Does parent need child info? â†’ YES
2. What should dfs return?
3. What is base value for null?
4. How to combine left & right?

If you answer these â†’ code writes itself.

---

## âš ï¸ COMMON MISTAKES (AVOID THESE)

âŒ Using preorder for height
âŒ Forgetting base case
âŒ Returning wrong value to parent
âŒ Mixing traversal and logic
âŒ Forgetting global update (diameter)

---

## ğŸ§­ INTERVIEW SPEAK (USE THIS LINE)

> â€œThis is a bottom-up tree problem where each node depends on information from its children, so Iâ€™ll use a postorder DFS that returns the required value.â€

This sentence alone sounds **senior-level**.

---

## ğŸ“Œ QUICK SUMMARY (ONE LOOK REVISION)

| Feature         | Rule                      |
| --------------- | ------------------------- |
| Traversal       | POSTORDER                 |
| DFS returns     | Value                     |
| Base case       | null â†’ base               |
| Parent uses     | children results          |
| Pattern used in | height, diameter, balance |

---

## ğŸ FINAL LOCK

> **Traversal = WHEN to visit**
> **Template 2 = WHAT to return**

Remember this distinction and **trees become easy**.

---

### ğŸ”œ NEXT STEP

When youâ€™re ready, we move to:

ğŸ‘‰ **PATTERN 3 â€” PATH PROBLEMS (Max Path Sum, Path Sum I/II/III)**
This is the **hardest and most important** tree pattern.

Just reply: **â€œNext patternâ€**
