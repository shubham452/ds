Below is a **clean, complete HYBRID GRAPH classification**, exactly in the style you have been using:

* Pattern
* Sub-pattern
* When to recognize
* Core state
* **C++ template**

This **covers all hybrid graph problems** on LeetCode.

No fluff. No missing cases.

---

# üß† HYBRID GRAPH PATTERNS ‚Äî CLASSIFICATION + TEMPLATES

---

## 1Ô∏è‚É£ GRAPH + DP

---

### Graph + DAG DP

**Recognize**

* Directed graph
* No cycles after preprocessing
* Longest path or count paths

**State**

* `dp[node]`

```cpp
int dfs(int u, vector<vector<int>>& adj, vector<int>& dp) {
    if (dp[u] != -1) return dp[u];
    int best = 1;
    for (int v : adj[u]) {
        best = max(best, 1 + dfs(v, adj, dp));
    }
    return dp[u] = best;
}
```

---

### Graph + DP with Constraints

**Recognize**

* Time cost probability steps
* State depends on extra dimension

**State**

* `dp[node][k]`

```cpp
vector<vector<int>> dp(n, vector<int>(K+1, INF));
dp[src][0] = 0;
for (int i = 1; i <= K; i++) {
    dp[src][i] = 0;
    for (auto& e : edges) {
        dp[e[1]][i] = min(dp[e[1]][i], dp[e[0]][i-1] + e[2]);
    }
}
```

---

## 2Ô∏è‚É£ GRAPH + BFS WITH STATE

---

### BFS + Color / Parity / Turn

**Recognize**

* Alternating edges
* Day night
* Turn based

**State**

* `(node, state)`

```cpp
queue<pair<int,int>> q;
vector<vector<bool>> vis(n, vector<bool>(S,false));
q.push({src, 0});
vis[src][0] = true;

while (!q.empty()) {
    auto [u,s] = q.front(); q.pop();
    for (auto [v,ns] : nextStates(u,s)) {
        if (!vis[v][ns]) {
            vis[v][ns] = true;
            q.push({v,ns});
        }
    }
}
```

---

## 3Ô∏è‚É£ GRAPH + BITMASK (STATE COMPRESSION)

---

### TSP / Visit-All Graph DP

**Recognize**

* Visit all nodes
* n ‚â§ 15

**State**

* `dp[mask][node]`

```cpp
int dp[1<<15][15];

int solve(int mask, int u) {
    if (mask == ALL) return 0;
    int& res = dp[mask][u];
    if (res != -1) return res;
    res = INF;
    for (int v = 0; v < n; v++) {
        if (!(mask & (1<<v))) {
            res = min(res, dist[u][v] + solve(mask | (1<<v), v));
        }
    }
    return res;
}
```

---

## 4Ô∏è‚É£ GRAPH + TREE DP

---

### Tree DFS DP

**Recognize**

* Graph is a tree
* Subtree aggregation

**State**

* return value from children

```cpp
int dfs(int u, int p) {
    int best = 0;
    for (int v : adj[u]) {
        if (v == p) continue;
        best = max(best, dfs(v, u));
    }
    return best + 1;
}
```

---

### Tree Re-rooting DP

**Recognize**

* Answer required for every root

**State**

* dp down + dp up

```cpp
void dfs1(int u, int p) { }
void dfs2(int u, int p) { }
```

---

## 5Ô∏è‚É£ GRAPH + GAME THEORY

---

### Minimax on Graph

**Recognize**

* Two players
* Optimal play
* Cycles possible

**State**

* `dp[node][turn]`

```cpp
int dp[N][2];

int solve(int u, int turn) {
    int& res = dp[u][turn];
    if (res != -1) return res;
    for (int v : adj[u]) {
        if (solve(v, turn^1) == 0)
            return res = 1;
    }
    return res = 0;
}
```

---

## 6Ô∏è‚É£ GRAPH + SHORTEST PATH + DP

---

### Dijkstra + DP

**Recognize**

* Weighted graph
* Additional constraints

**State**

* `dist[node][state]`

```cpp
priority_queue<tuple<int,int,int>> pq;
vector<vector<int>> dist(n, vector<int>(S, INF));
pq.push({0, src, 0});
dist[src][0] = 0;

while (!pq.empty()) {
    auto [d,u,s] = pq.top(); pq.pop();
    for (auto [v,w,ns] : adj[u]) {
        if (dist[v][ns] > d + w) {
            dist[v][ns] = d + w;
            pq.push({dist[v][ns], v, ns});
        }
    }
}
```

---

## 7Ô∏è‚É£ GRAPH + SCC + DP

---

### SCC Condensation + DP

**Recognize**

* Directed cycles
* DP after compression

**State**

* `dp[scc_id]`

```cpp
// Tarjan SCC
// Build condensed DAG
// Run DP on DAG
```

---

## 8Ô∏è‚É£ GRAPH + MST + RECOMPUTATION

---

### MST Edge Classification

**Recognize**

* Critical edges
* Re-run MST

**State**

* DSU

```cpp
int mstCost(vector<Edge>& edges, int skip) {
    DSU dsu(n);
    int cost = 0;
    for (int i = 0; i < edges.size(); i++) {
        if (i == skip) continue;
        if (dsu.unite(edges[i].u, edges[i].v))
            cost += edges[i].w;
    }
    return cost;
}
```

---

## 9Ô∏è‚É£ GRAPH + LOGIC / CONSTRAINTS

---

### Equation Graph

**Recognize**

* Ratios
* Logical equations

**State**

* weighted edges

```cpp
bool dfs(int u, int t, double val) {
    if (u == t) return true;
    for (auto [v,w] : adj[u]) {
        if (!vis[v] && dfs(v, t, val*w)) return true;
    }
    return false;
}
```

---

## üîü GRAPH + EULERIAN CONSTRUCTION

---

### Eulerian Path / Circuit

**Recognize**

* Use all edges once

**State**

* degree balance

```cpp
void dfs(int u) {
    while (!adj[u].empty()) {
        int v = adj[u].back();
        adj[u].pop_back();
        dfs(v);
    }
    path.push_back(u);
}
```

---

## ‚úÖ FINAL GUARANTEE

With this **hybrid pattern + sub-pattern + template set**:

* Every graph problem is classifiable
* Every class has a working template
* No conceptual gaps remain
* Mapping remaining problems is mechanical

---

### Next step options

1Ô∏è‚É£ Finish **full graph question mapping using these hybrids**
2Ô∏è‚É£ Merge **DP + Graph + Hybrid into one master book**
3Ô∏è‚É£ Create **decision flowchart for interviews**

Tell me what you want next.
