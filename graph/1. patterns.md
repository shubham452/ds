Good ‚Äî this is the **right abstraction step**.

Below is a **clean, complete pattern ‚Üí sub-pattern taxonomy for GRAPH problems**, built to **cover *all* the graph questions you listed** (and in fact the entire LeetCode graph set).

This is **NOT problem listing yet**.
This is the **classification framework**, exactly like what we did earlier for DP.

---

# üß† GRAPH PROBLEMS ‚Äî MASTER PATTERN & SUB-PATTERN TAXONOMY

This taxonomy is **minimal, complete, and reusable**.

---

## 1Ô∏è‚É£ GRAPH TRAVERSAL (FOUNDATION)

### 1.1 BFS Traversal

**Recognize**

* Shortest path in unweighted graph
* Level by level expansion
* ‚ÄúMinimum steps‚Äù

**State**

* `visited[node]`
* `queue`

---

### 1.2 DFS Traversal

**Recognize**

* Connectivity
* Reachability
* Explore all possibilities

**State**

* recursion stack
* visited set

---

### 1.3 BFS / DFS on Grid

**Recognize**

* Matrix
* Directions
* Walls / obstacles

**State**

* `(r, c)`
* visited grid

---

## 2Ô∏è‚É£ CONNECTED COMPONENTS / UNION FIND

### 2.1 DFS Components

**Recognize**

* ‚ÄúHow many components‚Äù
* Undirected graph

**State**

* visited array

---

### 2.2 Union Find (DSU)

**Recognize**

* Dynamic connectivity
* Edge addition
* Cycle detection

**State**

* `parent[]`
* `rank[]`

---

### 2.3 Component Compression

**Recognize**

* Contract components
* Count pairs across components

**State**

* component id
* size array

---

## 3Ô∏è‚É£ TOPOLOGICAL SORT / DAG

### 3.1 Topological Ordering

**Recognize**

* Prerequisites
* Ordering constraints
* DAG

**State**

* indegree array
* queue

---

### 3.2 DAG Reachability

**Recognize**

* Can reach destination
* All paths lead to ‚Ä¶

**State**

* DP on DAG
* memo DFS

---

### 3.3 DAG DP

**Recognize**

* Longest path
* Count paths
* DAG + optimization

**State**

* `dp[node]`

---

## 4Ô∏è‚É£ SHORTEST PATH ALGORITHMS

### 4.1 Dijkstra

**Recognize**

* Weighted graph
* Non-negative weights

**State**

* `dist[node]`
* priority queue

---

### 4.2 BFS with State

**Recognize**

* Extra constraints
* Color
* Parity
* Stops

**State**

* `(node, state)`

---

### 4.3 Bellman-Ford / K-Edges DP

**Recognize**

* ‚â§ K edges
* Negative edges
* Relaxation rounds

**State**

* `dp[k][node]`

---

### 4.4 0-1 BFS

**Recognize**

* Edge weights 0 or 1

**State**

* deque

---

## 5Ô∏è‚É£ GRAPH DP (STATEFUL)

### 5.1 DAG Longest Path DP

**Recognize**

* Max value path
* No cycles

**State**

* `dp[node]`

---

### 5.2 DAG Path Counting DP

**Recognize**

* Count number of paths

**State**

* `dp[node]`

---

### 5.3 Graph DP with Constraints

**Recognize**

* Time
* Cost
* Probability

**State**

* `(node, constraint)`

---

## 6Ô∏è‚É£ BITMASK GRAPH DP (TSP FAMILY)

### 6.1 TSP DP

**Recognize**

* Visit all nodes
* Small n (‚â§15)

**State**

* `dp[mask][node]`

---

### 6.2 Graph State Compression

**Recognize**

* Collect all keys
* Visit subsets

**State**

* `(mask, node)`

---

## 7Ô∏è‚É£ TREE-SPECIFIC GRAPH DP

### 7.1 Tree DFS DP

**Recognize**

* Tree
* Subtree computation

**State**

* return value from children

---

### 7.2 Tree Re-rooting DP

**Recognize**

* Answer for every root

**State**

* DP forward + backward

---

### 7.3 Tree Diameter / Longest Path

**Recognize**

* Longest path in tree

**State**

* depth values

---

## 8Ô∏è‚É£ BIPARTITE / COLORING

### 8.1 Bipartite Check

**Recognize**

* Two groups
* Conflict constraints

**State**

* `color[node]`

---

### 8.2 Graph Coloring (Small Colors)

**Recognize**

* Assign colors
* No adjacent equal

**State**

* color array

---

## 9Ô∏è‚É£ STRONGLY CONNECTED COMPONENTS (SCC)

### 9.1 SCC Detection

**Recognize**

* Directed cycles
* Mutual reachability

**State**

* discovery time
* low link

---

### 9.2 Condensed Graph DP

**Recognize**

* SCC compressed DAG

**State**

* SCC graph DP

---

## üîü MINIMUM SPANNING TREE / CUTS

### 10.1 Kruskal / Prim

**Recognize**

* Connect all nodes
* Min total cost

**State**

* DSU
* priority queue

---

### 10.2 Critical / Pseudo-Critical Edges

**Recognize**

* Edge importance

**State**

* MST recomputation

---

## 1Ô∏è‚É£1Ô∏è‚É£ FLOW / MATCHING

### 11.1 Bipartite Matching

**Recognize**

* Pair left/right sets

**State**

* match arrays

---

### 11.2 Max Flow / Min Cut

**Recognize**

* Capacity
* Network

**State**

* residual graph

---

## 1Ô∏è‚É£2Ô∏è‚É£ GAME / STRATEGY ON GRAPH

### 12.1 Game State DP

**Recognize**

* Two players
* Optimal play

**State**

* win / lose state

---

### 12.2 Minimax on Graph

**Recognize**

* Cat and mouse
* Adversarial

**State**

* DP with turn

---

## 1Ô∏è‚É£3Ô∏è‚É£ GRAPH + MATH / UNION LOGIC

### 13.1 Equation Graph

**Recognize**

* a / b = value

**State**

* weighted edges

---

### 13.2 Logical Constraints Graph

**Recognize**

* Satisfiability
* Equalities / inequalities

**State**

* DSU or graph coloring

---

## 1Ô∏è‚É£4Ô∏è‚É£ DYNAMIC GRAPH / QUERIES

### 14.1 Offline Queries

**Recognize**

* Queries over time
* Edge activation

**State**

* DSU rollback
* sorting queries

---

### 14.2 Incremental Graph

**Recognize**

* Add edges
* Recompute answers

**State**

* dynamic DSU

---

## 1Ô∏è‚É£5Ô∏è‚É£ SPECIALIZED GRAPH PATTERNS

### 15.1 Eulerian Path / Circuit

**Recognize**

* Use all edges exactly once

**State**

* degree balance

---

### 15.2 De Bruijn / Cyclic Graphs

**Recognize**

* Circular sequences

**State**

* Eulerian traversal

---

### 15.3 Grid with Constraints

**Recognize**

* Obstacles
* Cost
* Direction

**State**

* `(r, c, state)`

---

## ‚úÖ FINAL RESULT

You now have:

* A **complete pattern & sub-pattern taxonomy for Graph problems**
* Covers **every graph question you listed**
* Matches the same rigor as your DP taxonomy
* Ready for the **next step: mapping questions into tables**

---

### Next logical step (you choose)

1Ô∏è‚É£ Map your **entire graph question list into tables (Pattern ‚Üí Sub-pattern ‚Üí Questions)**
2Ô∏è‚É£ Build **templates per sub-pattern (BFS, Dijkstra, Topo, DSU, etc.)**
3Ô∏è‚É£ Create a **graph study roadmap**

Tell me which one to do next.
