
---

## 1. First: How do you *recognize* Sliding Window?

Ask these **three questions** immediately when you read a problem:

### Q1. Is the problem about **subarray / substring / contiguous segment**?

Keywords:

* subarray, substring
* consecutive
* window
* length `k`
* between indices `i` and `j`

ğŸ‘‰ If **YES**, Sliding Window is very likely.

---

### Q2. Is brute force `O(nÂ²)` obvious but too slow?

If checking all substrings / subarrays is easy but inefficient â†’ sliding window.

---

### Q3. Is there a **condition that becomes true/false as window grows or shrinks**?

Examples:

* at most `k`
* exactly `k`
* distinct characters
* sum â‰¤ target
* frequency constraint
* replace at most `k` characters

ğŸ‘‰ If the condition changes when you move left/right â†’ sliding window.

---

## 2. Two BIG categories of Sliding Window

Every sliding window problem fits into **one of these**:

---

## CATEGORY A: **Fixed Size Window (`k` is given)**

Window size is **constant**.

### Recognition

* â€œsubarray of size kâ€
* â€œsubstring of length kâ€
* average / sum / count over k elements

### Movement

* Right pointer moves forward
* Left pointer moves forward **every time** after window size reaches `k`

### Mental Model

> â€œKeep window size exactly `k`, update answer, slide.â€

---

### Template (C++ â€“ Fixed Window)

```cpp
int l = 0;
long long windowValue = 0;

for (int r = 0; r < n; r++) {
    // add right element
    windowValue += nums[r];

    if (r - l + 1 == k) {
        // process answer using windowValue
        ans = max(ans, windowValue);

        // remove left element
        windowValue -= nums[l];
        l++;
    }
}
```

---

### Problems from your list using this

* Maximum Average Subarray I
* Number of Sub-arrays of Size K and Average â‰¥ Threshold
* Maximum Number of Vowels in a Substring of Given Length
* K Radius Subarray Averages
* Maximum Sum of Distinct Subarrays With Length K

---

## CATEGORY B: **Variable Size Window**

Window expands and shrinks based on a **condition**.

### Recognition

* â€œat mostâ€
* â€œno more thanâ€
* â€œminimum windowâ€
* â€œlongest substringâ€
* â€œreplace k charactersâ€
* â€œdistinct / frequency constraintsâ€

---

## 3. Sub-patterns inside Variable Sliding Window

This is the **most important section**.

---

## PATTERN 1: **Longest window with AT MOST X**

### Recognition

* â€œlongestâ€
* â€œat most kâ€
* constraint violation â†’ shrink

### Core Rule

> Expand right
> While condition breaks â†’ shrink left

---

### Template (C++ â€“ Longest Valid Window)

```cpp
int l = 0;
unordered_map<char, int> freq;

for (int r = 0; r < n; r++) {
    freq[s[r]]++;

    while (condition_is_invalid(freq)) {
        freq[s[l]]--;
        if (freq[s[l]] == 0) freq.erase(s[l]);
        l++;
    }

    ans = max(ans, r - l + 1);
}
```

---

### Problems using this

* Longest Substring Without Repeating Characters
* Longest Repeating Character Replacement
* Fruit Into Baskets
* Max Consecutive Ones III
* Longest Continuous Subarray With Absolute Diff â‰¤ Limit

---

## PATTERN 2: **Count subarrays with AT MOST X**

### Trick

Instead of counting directly:

> Count subarrays ending at `r`

### Formula

For every `r`, valid subarrays = `(r - l + 1)`

---

### Template (C++ â€“ Count At Most)

```cpp
int l = 0;
long long count = 0;

for (int r = 0; r < n; r++) {
    add(nums[r]);

    while (invalid()) {
        remove(nums[l]);
        l++;
    }

    count += (r - l + 1);
}
```

---

### Problems using this

* Subarray Product Less Than K
* Count Number of Nice Subarrays
* Count the Number of Substrings With Dominant Ones

---

## PATTERN 3: **Exactly X = (At Most X) âˆ’ (At Most Xâˆ’1)**

### Recognition

* â€œexactly kâ€
* â€œk distinctâ€
* â€œexactly k oddsâ€

### Formula

```text
exactly(k) = atMost(k) - atMost(k-1)
```

---

### Template (C++ â€“ Exactly K)

```cpp
long long exactlyK(vector<int>& nums, int k) {
    return atMost(nums, k) - atMost(nums, k - 1);
}
```

---

### Problems using this

* Subarrays with K Different Integers
* Number of Nice Subarrays

---

## PATTERN 4: **Minimum Window (Shrink aggressively)**

### Recognition

* â€œminimum windowâ€
* â€œsmallest substringâ€
* must contain all required characters

### Core Idea

> Expand until valid
> Shrink as much as possible while valid

---

### Template (C++ â€“ Minimum Window)

```cpp
int l = 0;
int required = targetCount;
unordered_map<char, int> freq;

for (int r = 0; r < n; r++) {
    // include s[r]
    update(freq);

    while (window_is_valid()) {
        update_answer(l, r);

        // shrink
        remove(freq, s[l]);
        l++;
    }
}
```

---

### Problems using this

* Minimum Window Substring
* Substring with Concatenation of All Words

---

## PATTERN 5: **Two Pointers but NOT classic sliding window**

Used when **window condition is monotonic**.

### Examples

* Sliding Window Maximum (deque)
* Sliding Window Median (heap)
* Max Value of Equation

ğŸ‘‰ These require **auxiliary data structures**, not just maps.

---

## 4. How YOU should approach any new Sliding Window problem

### Step-by-step thought process

1. **Is it contiguous?**
   If no â†’ not sliding window.

2. **Is window size fixed or variable?**

   * Given `k` â†’ Fixed
   * Condition-based â†’ Variable

3. **Is it asking for**

   * max/min length?
   * count?
   * exactly / at most?

4. **Choose the pattern**

   * Longest at most
   * Count at most
   * Exactly = difference
   * Minimum window

5. **Write template FIRST**
   Then fill logic.

---

## 5. Mental Checklist (Very Important)

Before coding, say this out loud:

* What does `l` represent?
* What does `r` represent?
* When do I move `r`?
* When do I move `l`?
* What breaks the condition?
* When do I update the answer?

If you cannot answer these â†’ you donâ€™t understand the problem yet.

---

## 6. How I recommend you practice (effective method)

1. Take **ONE pattern**
2. Solve **5 problems of same pattern back-to-back**
3. Do NOT jump patterns randomly

Example order:

* Longest substring problems
* Count at most problems
* Exactly k problems
* Minimum window problems

---

## Next Step (important)

Tell me **one problem from your list** (e.g. *â€œLongest Repeating Character Replacementâ€*).

I will:

* Walk you through **recognition**
* Ask you **guided questions**
* Make you derive the solution yourself
  (no direct answer dump)

This is how sliding window actually sticks.
