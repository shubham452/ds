Here is the arrangement of the specific problems from your images into the **5 Master Patterns**.

I have categorized them so you know exactly which template to apply to each one.

### **Pattern 1: The Static Range Query (Read-Only)**

**Core Logic:** Precompute sums so you can answer "What is the total between index L and R?" in .

* **Range Sum Query - Immutable:** The textbook definition of this pattern.
* *Approach:* `P[i] = P[i-1] + nums[i]`. Result is `P[R+1] - P[L]`.


* **Count Vowel Strings in Ranges:** Same logic, but instead of summing numbers, you sum "isVowel" counts.
* *Approach:* Create a prefix array where `P[i]` is the count of vowel strings found up to index `i`.


* **Left and Right Sum Differences:** A simplified version where you need the sum of `0...i-1` (Prefix) and `i+1...N` (Total - Prefix).
* **Product of the Last K Numbers:** A variation using "Prefix Product".
* *Approach:* Store cumulative products. Product of last K is `TotalProduct / Product[N-K]`.



---

### **Pattern 2: The Difference Array (Range Updates / Sweep Line)**

**Core Logic:** "Events" happen at a start point and end point. You process the changes (start adds, end subtracts) to find the final state.

* **Car Pooling:** The classic Line Sweep problem.
* *Approach:* `diff[start] += passengers`, `diff[end] -= passengers`. Sweep and check if capacity is exceeded.


* **Shifting Letters II:** Range updates on characters.
* *Approach:* `diff[start] += 1` (shift forward), `diff[end+1] -= 1`. Compute prefix sum modulo 26 to get final shift.


* **Maximum Population Year:**
* *Approach:* `diff[birth] += 1`, `diff[death+1] -= 1`. Find the peak in the prefix sum.


* **Points That Intersect With Cars:**
* *Approach:* `diff[start] += 1`, `diff[end+1] -= 1`. Any index where prefix sum > 0 is covered.


* **Number of Flowers in Full Bloom:**
* *Approach:* Similar to population year, but usually requires sorting start/end times or using a TreeMap because the range of coordinates is large (1 to ).


* **Increment Submatrices by One:** **(2D Variation)**
* *Approach:* Use the **2D Difference Array** template. Update 4 corners: `(r1, c1)`, `(r1, c2+1)`, `(r2+1, c1)`, `(r2+1, c2+1)`.



---

### **Pattern 3: The Contribution Technique (Prefix + Suffix)**

**Core Logic:** The answer for index `i` depends on a cumulative stat from the **Left** combined with a cumulative stat from the **Right**.

* **Product of Array Except Self:** The most famous problem in this category.
* *Approach:* `Ans[i] = PrefixProduct[i-1] * SuffixProduct[i+1]`.


* **Find Good Days to Rob the Bank:**
* *Approach:*
* `Left[i]`: Continuous non-increasing days ending at `i`.
* `Right[i]`: Continuous non-decreasing days starting at `i`.
* Check if `Left[i] >= time` and `Right[i] >= time`.




* **Find All Good Indices:** Nearly identical logic to "Rob the Bank".
* **Minimum Penalty for a Shop:**
* *Approach:*
* `Prefix[i]`: Count of 'N' (No) before hour `i`.
* `Suffix[i]`: Count of 'Y' (Yes) after hour `i`.
* `Penalty[i] = Prefix[i] + Suffix[i]`. Find min.




* **Sum of Absolute Differences in a Sorted Array:**
* *Approach:* Mathematical derivation.
* `LeftContribution = i * nums[i] - PrefixSum[i]`
* `RightContribution = SuffixSum[i] - (N-1-i) * nums[i]`
* Add them up.





---

### **Pattern 4: 2D Prefix Sum (The Matrix)**

**Core Logic:** Calculating rectangular areas in a grid.

* **Range Sum Query 2D - Immutable:**
* *Approach:* Use the inclusion-exclusion formula: `Sum = P[r2][c2] - P[r1-1][c2] - P[r2][c1-1] + P[r1-1][c1-1]`.



---

### **Pattern 5: Sorting + Prefix Sum (Advanced Math)**

**Core Logic:** Sorting the array brings similar elements together, allowing "Prefix Sum" to answer questions about "making elements equal" or "weighted contributions".

* **Minimum Cost to Make Array Equal:**
* *Approach:* Sort the array. The optimal target is the **Median**. Calculating costs to move everyone to the median uses Prefix Sum logic (similar to "Sum of Absolute Differences").


* **Removing Minimum Number of Magic Beans:**
* *Approach:* Sort. If we choose to make all non-zero bags equal to `beans[i]`:
* We keep `beans[i] * (count of bags >= beans[i])`.
* The rest are removed.
* Use Total Sum - Kept Sum to find the minimum removal.




* **Movement of Robots:**
* *Approach:* The collision rule is a trick (robots pass through each other). Ignore collisions. Sort final positions. The sum of distances between all pairs can be calculated in  using Prefix Sums.



### **Summary of Your List**

| **Pattern** | **Problems from your upload** |
| --- | --- |
| **Static Range** | Range Sum Query, Count Vowel Strings, Left/Right Differences, Product Last K |
| **Difference Array** | Car Pooling, Shifting Letters II, Max Population Year, Points Intersect Cars, Flowers in Full Bloom, **Increment Submatrices (2D)** |
| **Prefix + Suffix** | Product Except Self, Good Days to Rob Bank, Find All Good Indices, Min Penalty Shop, Sum Absolute Differences |
| **2D Prefix** | Range Sum Query 2D |
| **Sort + Prefix** | Min Cost to Make Array Equal, Removing Magic Beans, Movement of Robots |
