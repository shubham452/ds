Here is the comprehensive **Master Guide** to Prefix Sum patterns. I have categorized them into 5 main patterns and their specific sub-patterns, including the C++ templates for each.

These cover 95% of prefix sum questions you will face in top-tier interviews (Google, Amazon, Uber).

---

### **Pattern 1: The Static Range Query (Read-Only)**

**Goal:** You have an array that doesn't change, and you need to answer many queries about range sums (or XORs) in .

#### **Main Template: Basic Prefix Sum**

* **Use Case:** "Calculate sum of elements between indices `L` and `R`."
* **Logic:** `Sum(L, R) = Prefix[R+1] - Prefix[L]`
* **Complexity:** Build , Query .

```cpp
// Template
vector<long long> prefix(n + 1, 0);
for (int i = 0; i < n; i++) {
    prefix[i + 1] = prefix[i] + nums[i];
}
// Query
long long sum = prefix[right + 1] - prefix[left];

```

#### **Sub-Pattern 1.A: XOR Prefix Sum**

* **Use Case:** "Find XOR of range `[L, R]`."
* **Why it works:** `x ^ x = 0`. Just like subtraction undoes addition, XOR undoes XOR.
* **Logic:** `Xor(L, R) = Prefix[R+1] ^ Prefix[L]` (Note: `^` instead of `-`).
* **Problem:** *XOR Queries of a Subarray*.

---

### **Pattern 2: The Difference Array (Range Updates)**

**Goal:** You need to **update** a range `[L, R]` by adding `X` many times, then query the final array.
**Also known as:** Line Sweep (on arrays).

#### **Main Template: 1D Difference Array**

* **Use Case:** "Add `val` to all elements from `L` to `R`."
* **Logic:** Update boundaries only. `Diff[L] += val`, `Diff[R+1] -= val`.
* **Complexity:** Update , Final Build .

```cpp
// Template
vector<int> diff(n + 1, 0);
for (auto& update : updates) {
    diff[update[0]] += update[2];      // Add at L
    if (update[1] + 1 < n) 
        diff[update[1] + 1] -= update[2]; // Subtract at R+1
}
// Reconstruct
int curr = 0;
for (int i = 0; i < n; i++) {
    curr += diff[i];
    nums[i] += curr; // Apply changes
}

```

#### **Sub-Pattern 2.A: 2D Difference Array**

* **Use Case:** "Add `val` to a submatrix `(r1, c1)` to `(r2, c2)`."
* **Logic:** 4 updates instead of 2.
* `diff[r1][c1] += val`
* `diff[r1][c2+1] -= val`
* `diff[r2+1][c1] -= val`
* `diff[r2+1][c2+1] += val`


* **Problem:** *Increment Submatrices by One*.

---

### **Pattern 3: The Contribution Technique (Pivot / Exclude)**

**Goal:** Calculate a result for *every* index `i` that depends on everything to its **left** and everything to its **right**.

#### **Main Template: Prefix + Suffix Arrays**

* **Use Case:** "Product of Array Except Self", "Rain Water Trapping".
* **Logic:**
1. Build `Left[]` (accumulation from 0 to N).
2. Build `Right[]` (accumulation from N to 0).
3. `Result[i]` combines `Left[i-1]` and `Right[i+1]`.



```cpp
// Template
vector<int> left(n, 1), right(n, 1);
for(int i=1; i<n; i++) left[i] = left[i-1] * nums[i-1];
for(int i=n-2; i>=0; i--) right[i] = right[i+1] * nums[i+1];

// Result
for(int i=0; i<n; i++) ans[i] = left[i] * right[i];

```

#### **Sub-Pattern 3.A: Equilibrium Index**

* **Use Case:** "Find index where sum of left elements equals sum of right elements."
* **Optimization:** You don't need a `Suffix` array.
* `RightSum = TotalSum - LeftSum - nums[i]`.
* Check: `if (LeftSum == RightSum) return i`.



---

### **Pattern 4: The HashMap Variant (Subarray Constraints)**

**Goal:** Find **how many** subarrays satisfy a condition (Sum = K, Sum is divisible by K).
**Why HashMap?** Because  to check every subarray is too slow. We use algebra: `Sum(i, j) = P[j] - P[i]`. If we want `Sum = K`, we look for `P[i] = P[j] - K`.

#### **Main Template: Subarray Sum Equals K**

* **Use Case:** "Count continuous subarrays summing to K."
* **Logic:** Store frequency of prefix sums seen so far.
* **Complexity:** .

```cpp
// Template
unordered_map<int, int> map;
map[0] = 1; // Base case: Sum 0 seen once
int curr = 0, count = 0;
for(int x : nums) {
    curr += x;
    if(map.count(curr - k)) count += map[curr - k];
    map[curr]++;
}

```

#### **Sub-Pattern 4.A: Divisible by K**

* **Use Case:** "Count subarrays where sum is divisible by K."
* **Logic:** Instead of storing `curr`, store `curr % k`.
* *Math:* `(a - b) % k == 0` implies `a % k == b % k`.
* *Correction:* Handle negative mods in C++: `rem = ((curr % k) + k) % k`.



#### **Sub-Pattern 4.B: Longest Subarray with Equal 0s and 1s**

* **Use Case:** "Find longest subarray with equal number of 0s and 1s."
* **Logic:** Treat `0` as `-1`. Problem becomes "Longest subarray with Sum = 0". Use HashMap to store the **first index** where you saw a prefix sum.

---

### **Pattern 5: 2D Prefix Sum (The Matrix)**

**Goal:** Calculate sum of a rectangle inside a matrix in .

#### **Main Template: 2D Immutable Sum**

* **Use Case:** *Range Sum Query 2D - Immutable*.
* **Logic:** Principle of Inclusion-Exclusion.
* **Formula:** `Sum = P[r2][c2] - P[r1-1][c2] - P[r2][c1-1] + P[r1-1][c1-1]`

```cpp
// Template (Precomputation)
// dp[i][j] stores sum of rectangle from (0,0) to (i,j)
for(int i=1; i<=R; i++) {
    for(int j=1; j<=C; j++) {
        dp[i][j] = matrix[i-1][j-1] 
                 + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];
    }
}

```

### **Summary Checklist**

| If the problem asks... | Use Pattern | Sub-Pattern |
| --- | --- | --- |
| Sum of range `[L, R]` queries | **1. Static Range** | Basic |
| XOR of range `[L, R]` queries | **1. Static Range** | **XOR Prefix** |
| Add `X` to range `[L, R]` | **2. Diff Array** | Basic |
| Add `X` to rectangle `(r1,c1)-(r2,c2)` | **2. Diff Array** | **2D Diff Array** |
| Product of array except self | **3. Contribution** | Basic |
| Find index where Left Sum = Right Sum | **3. Contribution** | **Equilibrium** |
| Count subarrays with Sum = K | **4. HashMap** | Basic |
| Count subarrays divisible by K | **4. HashMap** | **Modulo Math** |
| Longest subarray with equal 0s and 1s | **4. HashMap** | **Treat 0 as -1** |
| Sum of sub-rectangle | **5. 2D Prefix** | Basic |
